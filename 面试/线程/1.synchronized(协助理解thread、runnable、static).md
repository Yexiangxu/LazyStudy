先来个最常见的卖票系统引入主题

```agsl
class TicketRunnable : Runnable {
    private var ticket = AtomicInteger(30)

    //@Synchronized
    override fun run() {
        while (true) {
            if (ticket.get() > 0) {
                println("${Thread.currentThread().name} :卖出了第 ${ticket.getAndDecrement()} 张票")
            } else {
                println("${Thread.currentThread().name} :余票不足,停止售票!")
                return
            }
        }
    }
}
```

```agsl
val ticketRunnable = TicketRunnable()
val thread1 = Thread(ticketRunnable, "窗口1")
val thread2 = Thread(ticketRunnable, "窗口2")
thread1.start()
thread2.start()

结果：
窗口2 :卖出了第 29 张票
窗口1 :卖出了第 30 张票
窗口2 :卖出了第 28 张票
窗口1 :卖出了第 27 张票
窗口2 :卖出了第 26 张票
窗口1 :卖出了第 25 张票
窗口2 :卖出了第 24 张票
窗口1 :卖出了第 23 张票
窗口2 :卖出了第 22 张票
窗口1 :卖出了第 21 张票
窗口1 :卖出了第 19 张票
窗口2 :卖出了第 20 张票
窗口2 :卖出了第 17 张票
窗口2 :卖出了第 16 张票
窗口2 :卖出了第 15 张票
窗口2 :卖出了第 14 张票
窗口2 :卖出了第 13 张票
窗口2 :卖出了第 12 张票
窗口1 :卖出了第 18 张票
窗口2 :卖出了第 11 张票
窗口2 :卖出了第 10 张票
窗口2 :卖出了第 8 张票
窗口2 :卖出了第 7 张票
窗口2 :卖出了第 6 张票
窗口2 :卖出了第 5 张票
窗口2 :卖出了第 4 张票
窗口2 :卖出了第 3 张票
窗口2 :卖出了第 2 张票
窗口2 :卖出了第 1 张票
窗口1 :卖出了第 9 张票
窗口2 :余票不足,停止售票!
窗口1 :余票不足,停止售票!
```

很明显上面线程不安全，卖票数据错乱了。要想数据安全把上面@Synchronized注释放开即可

```agsl
结果：
窗口1 :卖出了第 30 张票
窗口1 :卖出了第 29 张票
窗口1 :卖出了第 28 张票
窗口1 :卖出了第 27 张票
窗口1 :卖出了第 26 张票
窗口1 :卖出了第 25 张票
窗口1 :卖出了第 24 张票
窗口1 :卖出了第 23 张票
窗口1 :卖出了第 22 张票
窗口1 :卖出了第 21 张票
窗口1 :卖出了第 20 张票
窗口1 :卖出了第 19 张票
窗口1 :卖出了第 18 张票
窗口1 :卖出了第 17 张票
窗口1 :卖出了第 16 张票
窗口1 :卖出了第 15 张票
窗口1 :卖出了第 14 张票
窗口1 :卖出了第 13 张票
窗口1 :卖出了第 12 张票
窗口1 :卖出了第 11 张票
窗口1 :卖出了第 10 张票
窗口1 :卖出了第 9 张票
窗口1 :卖出了第 8 张票
窗口1 :卖出了第 7 张票
窗口1 :卖出了第 6 张票
窗口1 :卖出了第 5 张票
窗口1 :卖出了第 4 张票
窗口1 :卖出了第 3 张票
窗口1 :卖出了第 2 张票
窗口1 :卖出了第 1 张票
窗口1 :余票不足,停止售票!
窗口2 :余票不足,停止售票!
```

很明显上面结果虽然线程安全了，但并不是按照实际预期走的，因为所有的票都被一个窗口卖了，预期应该是两个窗口随机卖票但不会出现数据错乱，如何解决该问题？使用上面说的不要用
Synchronized 修复非静态方法而是修饰代码块即可

```agsl
class TicketRunnable : Runnable {
    private var ticket = AtomicInteger(30)
    override fun run() {
        while (true) {
            synchronized(this){
                if (ticket.get() > 0) {
                    println("${Thread.currentThread().name} :卖出了第 ${ticket.getAndDecrement()} 张票")
                } else {
                    println("${Thread.currentThread().name} :余票不足,停止售票!")
                    return
                }
            }
        }
    }
}

结果
窗口1 :卖出了第 30 张票
窗口1 :卖出了第 29 张票
窗口1 :卖出了第 28 张票
窗口2 :卖出了第 27 张票
窗口2 :卖出了第 26 张票
窗口2 :卖出了第 25 张票
窗口2 :卖出了第 24 张票
窗口2 :卖出了第 23 张票
窗口2 :卖出了第 22 张票
窗口2 :卖出了第 21 张票
窗口2 :卖出了第 20 张票
窗口2 :卖出了第 19 张票
窗口2 :卖出了第 18 张票
窗口2 :卖出了第 17 张票
窗口2 :卖出了第 16 张票
窗口2 :卖出了第 15 张票
窗口2 :卖出了第 14 张票
窗口2 :卖出了第 13 张票
窗口2 :卖出了第 12 张票
窗口2 :卖出了第 11 张票
窗口2 :卖出了第 10 张票
窗口2 :卖出了第 9 张票
窗口2 :卖出了第 8 张票
窗口2 :卖出了第 7 张票
窗口2 :卖出了第 6 张票
窗口2 :卖出了第 5 张票
窗口2 :卖出了第 4 张票
窗口2 :卖出了第 3 张票
窗口2 :卖出了第 2 张票
窗口2 :卖出了第 1 张票
窗口2 :余票不足,停止售票!
窗口1 :余票不足,停止售票!
```

------------------

### 一. 修饰代码块

```agsl
public class MyClass {  
    public void method() {  
        synchronized(this) {//this（实例对象） ，是对象级锁 
            // 代码块  
        }  
    }  
}
```

如上面卖票系统，当一个线程进入一个对象的一个`synchronized(this)`
代码块时，其他线程对此对象的所有其他`synchronized(this)`代码块的访问将被阻塞

- 作用范围：this是大括号{}括起来的代码；
- 作用对象：
    - this是调用这个代码块的对象
    - 自定义lock是自定义的lock对象

### 二. 修饰非静态方法(被修饰的方法称为同步方法)

```agsl
public class MyClass {  
    public synchronized void method() {  
        // 方法体  
    }  
}
```

- 作用范围：整个方法
- 行为：每次只有一个线程能够执行该实例的 synchronized 方法，其他线程需要等到锁释放
- 作用对象：调用这个方法的对象

### 三. 修饰静态方法(跟下面同步一个类等效)

```agsl
public class MyClass {  
    public static synchronized void method() {  
        // 方法体  
    }  
}
```

当一个线程访问某个类的synchronized静态方法时，其他线程对这个类的所有其他synchronized静态方法的访问将被阻塞

- 作用范围：整个静态方法
- 作用对象：该类的所有对象

### 四. 同步一个类

```agsl
public class MyClass {  
    public static void method() {  
        synchronized(MyClass.class) {  
            // 代码块  
        }  
    }  
}
```

synchronized(MyClass.class)用于同步一个类，阻止多个线程同时执行这个类的synchronized代码块



## synchronized 不同场景对比表

| 场景描述                          | 代码块<br>(锁 `this`) | 自定义对象锁 | 非静态方法<br>(锁 `this`) | 静态方法<br>(锁 `Class`) | 类锁<br>(`Class.class`) |
|-----------------------------------|-------------------|-------------|---------------------|---------------------|-------------------------|
| **同一对象访问同一个同步方法**     | ✅ 互斥              | ✅ 互斥     | ✅ 互斥                | ✅ 互斥                | ✅ 互斥                 |
| **同一对象访问不同同步方法**       | ✅ 互斥 (`this`是调用该代码块的对象，同一对象调用 `methodA()` 和 `methodB()`，两个方法共享 `this` 锁)           | ✅ 互斥     | ✅ 互斥(作用对象：调用这个方法的对象)              | ✅ 互斥(作用对象：该类的所有对象)              | ✅ 互斥                 |
| **不同对象访问同一个同步方法**     | ❌ 不互斥（锁的不同对象）     | ❌ 不互斥   | ❌ 不互斥（锁的不同对象）                 | ✅ 互斥(锁的是 Class 对象)               | ✅ 互斥                 |
| **不同对象访问不同同步方法**       | ❌ 不互斥             | ❌ 不互斥   | ❌ 不互斥               | ✅ 互斥| ✅ 互斥                 |


| 场景描述                          | 是否互斥 | 原因 |
|-----------------------------------|-------------------|-------------|
| **同一对象调用非静态A和静态B**     | ❌ 不互斥            |锁对象不同（this vs Class） | 


### 关键结论

1. **对象级锁**（非静态方法/`this`代码块）：仅对同一对象实例的访问互斥
2. **类级锁**（静态方法/`Class.class`）：对所有对象实例的访问互斥
3. **自定义锁**：灵活性最高，可控制更细粒度的同步
