1. [为什么多线程同时访问（读写）同个变量，会有并发问题？](#jump1)
2. [并发三要素](#jump2)
3. [如何解决并发问题](#jump3)
4. [以常见多个窗口卖票系统实际场景解决线程安全](./1.synchronized(协助理解thread、runnable、static).md)
5. [线程相关面试题](#jump5)

--------------------

### <span id = "jump1">为什么多线程同时访问（读写）同个变量，会有并发问题？</span>

> 1. **Java 内存模型规定了所有的变量都存储在`主内存`中，每条线程有自己的`工作内存`
     。（可以理解为每个线程都有自己的一个执行区域，将某个值拷贝到自己的内存做处理）**
> 2. 线程的工作内存中保存了该线程中用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。
> 3. 线程访问一个变量，首先将变量从主内存拷贝到工作内存，对变量的写操作，不会马上同步到主内存。
> 4. 不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。
--------------------

### <span id = "jump2">并发三要素</span>

1. **原子性**：在一个操作中，CPU 不可以在中途暂停然后再调度，即不被中断操作，要么执行完成，要么就不执行
   >场景理解：A和B同时向C转账10万元，如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作继续——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万
2. **可见性**：多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值
3. **有序性**:程序执行的顺序按照代码的先后顺序执行

------------------

### <span id = "jump3">如何解决并发问题</span>

1. Atomic —— 保证原子性

   Atomic多用于类似**计数器相关的变量**
2. volatile —— 保证可见性，禁止指令重排序，不保证原子性

    volatile多修饰类似**开关**类型的变量
    boolean，[单例模式中防止指令重排](../架构——设计模式/2.单例模式.md)
    
    ```agsl
    当写一个volatile变量时，JVM会把本地内存的变量强制刷新到主内存中
    这个写操作导致其他线程中的缓存无效，其他线程读，会从主内存读。volatile的写操作对其它线程实时可见。
    ```

3. #### [synchronized —— 三要素都能保证](./1.synchronized(协助理解thread、runnable、static).md)

    缺点： 不能设置锁超时时间 不能通过代码释放锁 容易造成死锁


-----------
